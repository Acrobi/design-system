#!/usr/bin/env node

/**
 * Acrobi Design System CLI
 *
 * A command-line interface for managing themes and design system operations.
 * Provides utilities for theme creation, validation, and management.
 */

const { Command } = require('commander');
const fs = require('fs');
const path = require('path');

// Try to load optional dependencies
let chalk, inquirer;
try {
  chalk = require('chalk');
} catch (e) {
  // Fallback if chalk is not available
  chalk = {
    red: (text) => `\x1b[31m${text}\x1b[0m`,
    green: (text) => `\x1b[32m${text}\x1b[0m`,
    yellow: (text) => `\x1b[33m${text}\x1b[0m`,
    blue: (text) => `\x1b[34m${text}\x1b[0m`,
    gray: (text) => `\x1b[90m${text}\x1b[0m`,
    white: (text) => `\x1b[37m${text}\x1b[0m`
  };
}

try {
  inquirer = require('inquirer');
} catch (e) {
  // Fallback if inquirer is not available
  inquirer = null;
}

const program = new Command();

// CLI version
const VERSION = '1.0.0';

// Theme management utilities
class ThemeManager {
  constructor() {
    this.themesDir = path.join(process.cwd(), 'public/themes');
    this.availableThemes = ['base', 'blue', 'purple', 'green', 'red', 'orange'];
  }

  async createTheme(name, options = {}) {
    console.log(chalk.blue(`üé® Creating theme: ${name}`));

    const themePath = path.join(this.themesDir, `${name}.css`);

    if (fs.existsSync(themePath) && !options.force) {
      if (!inquirer) {
        console.log(chalk.yellow(`Theme ${name} already exists. Use --force to overwrite.`));
        return;
      }
      const { overwrite } = await inquirer.prompt([
        {
          type: 'confirm',
          name: 'overwrite',
          message: `Theme ${name} already exists. Overwrite?`,
          default: false
        }
      ]);

      if (!overwrite) {
        console.log(chalk.yellow('Theme creation cancelled.'));
        return;
      }
    }

    const baseColor = options.color || '#9333ea';
    const isDark = options.dark || false;

    const themeContent = this.generateThemeCSS(name, baseColor, isDark);

    // Ensure themes directory exists
    if (!fs.existsSync(this.themesDir)) {
      fs.mkdirSync(this.themesDir, { recursive: true });
    }

    fs.writeFileSync(themePath, themeContent);
    console.log(chalk.green(`‚úÖ Theme created: ${themePath}`));
  }

  generateThemeCSS(name, baseColor, isDark = false) {
    // Simple color generation logic
    const colors = this.generateColorPalette(baseColor, isDark);

    return `/**
 * ${name} Theme
 * Generated by Acrobi Design System CLI
 * Date: ${new Date().toISOString()}
 */

:root {
  /* Primary Color Palette */
  --primary: ${colors.primary};
  --primary-foreground: ${colors.primaryForeground};

  /* Background Colors */
  --background: ${colors.background};
  --foreground: ${colors.foreground};

  /* Surface Colors */
  --card: ${colors.card};
  --card-foreground: ${colors.cardForeground};
  --popover: ${colors.popover};
  --popover-foreground: ${colors.popoverForeground};

  /* Muted Colors */
  --muted: ${colors.muted};
  --muted-foreground: ${colors.mutedForeground};

  /* Accent Colors */
  --accent: ${colors.accent};
  --accent-foreground: ${colors.accentForeground};

  /* Border Colors */
  --border: ${colors.border};
  --input: ${colors.input};
  --ring: ${colors.ring};

  /* Destructive Colors */
  --destructive: ${colors.destructive};
  --destructive-foreground: ${colors.destructiveForeground};

  /* Radius */
  --radius: 0.5rem;
}

${isDark ? '.dark {' : ''}
${isDark ? `  --background: ${colors.darkBackground};
  --foreground: ${colors.darkForeground};
  --card: ${colors.darkCard};
  --card-foreground: ${colors.darkCardForeground};
  --popover: ${colors.darkPopover};
  --popover-foreground: ${colors.darkPopoverForeground};
  --muted: ${colors.darkMuted};
  --muted-foreground: ${colors.darkMutedForeground};
  --accent: ${colors.darkAccent};
  --accent-foreground: ${colors.darkAccentForeground};
  --border: ${colors.darkBorder};
  --input: ${colors.darkInput};` : ''}
${isDark ? '}' : ''}
`;
  }

  generateColorPalette(baseColor, isDark) {
    // This is a simplified color generation
    // In a real implementation, you'd use a color library
    return {
      primary: baseColor,
      primaryForeground: isDark ? '#fafafa' : '#0a0a0a',
      background: isDark ? '#0a0a0a' : '#fafafa',
      foreground: isDark ? '#fafafa' : '#0a0a0a',
      card: isDark ? '#18181b' : '#ffffff',
      cardForeground: isDark ? '#fafafa' : '#0a0a0a',
      popover: isDark ? '#18181b' : '#ffffff',
      popoverForeground: isDark ? '#fafafa' : '#0a0a0a',
      muted: isDark ? '#27272a' : '#f4f4f5',
      mutedForeground: isDark ? '#a1a1aa' : '#71717a',
      accent: isDark ? '#27272a' : '#f4f4f5',
      accentForeground: isDark ? '#fafafa' : '#0a0a0a',
      border: isDark ? '#27272a' : '#e4e4e7',
      input: isDark ? '#27272a' : '#e4e4e7',
      ring: baseColor,
      destructive: isDark ? '#dc2626' : '#ef4444',
      destructiveForeground: isDark ? '#fafafa' : '#0a0a0a',
      // Dark variants
      darkBackground: '#0a0a0a',
      darkForeground: '#fafafa',
      darkCard: '#18181b',
      darkCardForeground: '#fafafa',
      darkPopover: '#18181b',
      darkPopoverForeground: '#fafafa',
      darkMuted: '#27272a',
      darkMutedForeground: '#a1a1aa',
      darkAccent: '#27272a',
      darkAccentForeground: '#fafafa',
      darkBorder: '#27272a',
      darkInput: '#27272a'
    };
  }

  listThemes() {
    console.log(chalk.blue('üìã Available themes:'));

    if (!fs.existsSync(this.themesDir)) {
      console.log(chalk.yellow('No themes directory found.'));
      return;
    }

    const themes = fs.readdirSync(this.themesDir)
      .filter(file => file.endsWith('.css'))
      .map(file => file.replace('.css', ''));

    if (themes.length === 0) {
      console.log(chalk.yellow('No themes found.'));
      return;
    }

    themes.forEach(theme => {
      const themePath = path.join(this.themesDir, `${theme}.css`);
      const stats = fs.statSync(themePath);
      const lastModified = stats.mtime.toLocaleDateString();

      console.log(chalk.green(`  ‚úì ${theme}`) + chalk.gray(` (modified: ${lastModified})`));
    });
  }

  validateTheme(themeName) {
    const themePath = path.join(this.themesDir, `${themeName}.css`);

    if (!fs.existsSync(themePath)) {
      console.log(chalk.red(`‚ùå Theme "${themeName}" not found.`));
      return false;
    }

    const content = fs.readFileSync(themePath, 'utf8');
    const requiredVariables = [
      '--primary', '--primary-foreground',
      '--background', '--foreground',
      '--card', '--card-foreground',
      '--muted', '--muted-foreground',
      '--accent', '--accent-foreground',
      '--border', '--input', '--ring'
    ];

    const missingVariables = requiredVariables.filter(variable => {
      const regex = new RegExp(variable.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&') + '\\s*:');
      return !regex.test(content);
    });

    if (missingVariables.length > 0) {
      console.log(chalk.red(`‚ùå Theme "${themeName}" validation failed.`));
      console.log(chalk.yellow('Missing variables:'));
      missingVariables.forEach(variable => {
        console.log(chalk.red(`  - ${variable}`));
      });
      return false;
    }

    console.log(chalk.green(`‚úÖ Theme "${themeName}" is valid.`));
    return true;
  }

  exportTheme(themeName, outputPath) {
    const themePath = path.join(this.themesDir, `${themeName}.css`);

    if (!fs.existsSync(themePath)) {
      console.log(chalk.red(`‚ùå Theme "${themeName}" not found.`));
      return;
    }

    const content = fs.readFileSync(themePath, 'utf8');
    const exportPath = outputPath || `${themeName}-exported.css`;

    fs.writeFileSync(exportPath, content);
    console.log(chalk.green(`‚úÖ Theme exported to: ${exportPath}`));
  }
}

// Initialize theme manager
const themeManager = new ThemeManager();

// CLI commands
program
  .name('acrobi-design')
  .description('CLI for managing Acrobi Design System themes and components')
  .version(VERSION);

program
  .command('create-theme <name>')
  .description('Create a new theme')
  .option('-c, --color <color>', 'Base color for the theme (hex)', '#9333ea')
  .option('-d, --dark', 'Create a dark theme variant')
  .option('-f, --force', 'Overwrite existing theme')
  .action(async (name, options) => {
    try {
      await themeManager.createTheme(name, options);
    } catch (error) {
      console.error(chalk.red('Error creating theme:'), error.message);
      process.exit(1);
    }
  });

program
  .command('list-themes')
  .alias('ls')
  .description('List all available themes')
  .action(() => {
    try {
      themeManager.listThemes();
    } catch (error) {
      console.error(chalk.red('Error listing themes:'), error.message);
      process.exit(1);
    }
  });

program
  .command('validate-theme <name>')
  .description('Validate a theme file')
  .action((name) => {
    try {
      const isValid = themeManager.validateTheme(name);
      process.exit(isValid ? 0 : 1);
    } catch (error) {
      console.error(chalk.red('Error validating theme:'), error.message);
      process.exit(1);
    }
  });

program
  .command('export-theme <name>')
  .description('Export a theme to a file')
  .option('-o, --output <path>', 'Output path for the exported theme')
  .action((name, options) => {
    try {
      themeManager.exportTheme(name, options.output);
    } catch (error) {
      console.error(chalk.red('Error exporting theme:'), error.message);
      process.exit(1);
    }
  });

program
  .command('validate-all')
  .description('Validate all theme files')
  .action(() => {
    try {
      if (!fs.existsSync(themeManager.themesDir)) {
        console.log(chalk.yellow('No themes directory found.'));
        return;
      }

      const themes = fs.readdirSync(themeManager.themesDir)
        .filter(file => file.endsWith('.css'))
        .map(file => file.replace('.css', ''));

      if (themes.length === 0) {
        console.log(chalk.yellow('No themes found.'));
        return;
      }

      let validCount = 0;
      themes.forEach(theme => {
        const isValid = themeManager.validateTheme(theme);
        if (isValid) validCount++;
      });

      console.log(chalk.blue(`\nValidation complete: ${validCount}/${themes.length} themes are valid.`));
    } catch (error) {
      console.error(chalk.red('Error validating themes:'), error.message);
      process.exit(1);
    }
  });

program
  .command('info')
  .description('Display design system information')
  .action(() => {
    console.log(chalk.blue('üé® Acrobi Design System CLI'));
    console.log(chalk.gray(`Version: ${VERSION}`));
    console.log(chalk.gray('Description: Theme management and design system utilities'));
    console.log('');
    console.log(chalk.green('Available commands:'));
    console.log(chalk.white('  create-theme <name>   Create a new theme'));
    console.log(chalk.white('  list-themes           List all available themes'));
    console.log(chalk.white('  validate-theme <name> Validate a theme file'));
    console.log(chalk.white('  export-theme <name>   Export a theme to a file'));
    console.log(chalk.white('  validate-all          Validate all theme files'));
    console.log(chalk.white('  info                  Display this information'));
    console.log('');
    console.log(chalk.yellow('Example usage:'));
    console.log(chalk.gray('  acrobi-design create-theme my-theme --color #ff6b6b'));
    console.log(chalk.gray('  acrobi-design validate-theme my-theme'));
    console.log(chalk.gray('  acrobi-design list-themes'));
  });

// Parse command line arguments
program.parse();

// Handle unknown commands
program.on('command:*', (operands) => {
  console.error(chalk.red(`Unknown command: ${operands[0]}`));
  console.log(chalk.yellow('Use "acrobi-design info" for available commands.'));
  process.exit(1);
});